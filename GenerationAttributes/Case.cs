using System;
using System.Diagnostics;

namespace GenerationAttributes
{
    /// <summary>
    /// <code><![CDATA[
    ///    None = 0,
    ///    Constructor = 1,
    ///    Apply =   Constructor | 1 << 1,
    ///    Copy =    Constructor | 1 << 2,
    ///    Withers = Constructor | 1 << 3,
    ///    Default = Constructor | Copy | Withers,
    ///    All =     Constructor | Apply | Copy | Withers
    /// ]]></code>
    /// </summary>
    [Flags]
    public enum ConstructorFlags
    {
        None = 0,
        Constructor = 1,
        Apply =   Constructor | 1 << 1,
        Copy =    Constructor | 1 << 2,
        Withers = Constructor | 1 << 3,
        Default = Constructor | Copy | Withers,
        All =     Constructor | Apply | Copy | Withers
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    [Conditional(Consts.UNUSED_NAME)]
    public class RecordAttribute : Attribute
    {
        public bool GenerateToString { get; set; } = true;
        public bool GenerateComparer { get; set; } = true;
        public bool GenerateGetHashCode { get; set; } = true;
        // Can't use nullable in attributes
        public ConstructorFlags GenerateConstructor { get; set; } = ConstructorFlags.Default;
    }
    
    /// <summary>
    /// Controls omission of fields in code generated by <see cref="RecordAttribute"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
    [Conditional(Consts.UNUSED_NAME)]
    public class RecordSkipAttribute : Attribute {
        /// <summary>Should we skip this field when creating a constructor?</summary>
        public bool SkipInConstructor { get; set; } = false;
        /// <summary>Should we skip this field when creating <see cref="object.Equals(object)"/>?</summary>
        public bool SkipInEquals { get; set; } = true;
        /// <summary>Should we skip this field when creating <see cref="object.GetHashCode()"/>?</summary>
        public bool SkipInHashCode { get; set; } = true;
        /// <summary>Should we skip this field when creating <see cref="object.ToString()"/>?</summary>
        public bool SkipInToString { get; set; } = true;
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface)]
    [Conditional(Consts.UNUSED_NAME)]
    public class MatcherAttribute : Attribute
    {
        public string ClassName { get; set; } = null;
    }

    /// <summary>
    /// Exposes a field as a public property.
    ///
    /// If it is possible the name is computed by stripping a _ from the beginning of the field name. If it clashes
    /// with another name, the name will instead be computed by adding _ to the end of the field name. 
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    [Conditional(Consts.UNUSED_NAME)]
    public class PublicAccessor : Attribute {}

    /// <summary>
    /// Generates a private no-args constructor and a static readonly field named <see cref="InstanceMethodName"/>
    /// to access this singleton class.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    [Conditional(Consts.UNUSED_NAME)]
    public class SingletonAttribute : Attribute {
        public string InstanceMethodName { get; set; } = "instance";
    }

    static class Consts {
        /// <summary>
        /// Dummy name that we should never encounter in compiler defines list.
        /// Purpose: we want to remove instances of some attributes from compiled code.
        /// Eg.: We put a [Record] attribute on some class in a project X that is being compiled with this compiler.
        /// Then C# compiler would strip that attribute from the compiled project X dll.
        /// </summary>
        public const string UNUSED_NAME = "____CodeGeneration____";
    }
}
